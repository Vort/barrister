#pragma once

#include "LifeAPI.h"
#include "Bits.hpp"
#include "LifeStableState.hpp"

class LifeUnknownState {
public:
  LifeState state;
  LifeState unknown;
  LifeState unknownStable;
  LifeState glanceableUnknown;

  LifeUnknownState UncertainStepMaintaining(const LifeStableState &stable) const;
  LifeUnknownState UncertainStepFast(const LifeStableState &stable) const;
  LifeState ActiveComparedTo(const LifeStableState &stable) const;
  bool CompatibleWith(const LifeStableState &stable) const;

  void UncertainStepColumn(int column, uint64_t &next, uint64_t &nextUnknown) const;
  std::pair<bool, bool> NextForCell(std::pair<int, int> cell) const;
  bool KnownNext(std::pair<int, int> cell) const;

  bool StillGlancingFor(std::pair<int, int> cell, const LifeStableState &stable) const;
};

LifeUnknownState LifeUnknownState::UncertainStepFast(const LifeStableState &stable) const {
  LifeUnknownState result;

  LifeState state3(false), state2(false), state1(false), state0(false);
  LifeState unknown3(false), unknown2(false), unknown1(false), unknown0(false);

  CountNeighbourhood(state, state3, state2, state1, state0);
  CountNeighbourhood(unknown, unknown3, unknown2, unknown1, unknown0);

  #pragma clang loop unroll(full)
  for (int i = 0; i < N; i++) {
    uint64_t on3 = state3[i];
    uint64_t on2 = state2[i];
    uint64_t on1 = state1[i];
    uint64_t on0 = state0[i];

    uint64_t unk3 = unknown3[i];
    uint64_t unk2 = unknown2[i];
    uint64_t unk1 = unknown1[i];
    uint64_t unk0 = unknown0[i];

    on2 |= on3;
    on1 |= on3;
    on0 |= on3;

    unk1 |= unk2 | unk3;
    unk0 |= unk2 | unk3;

    uint64_t stateon = state[i];
    uint64_t stateunk = unknown[i];

    uint64_t next_on = 0;
    uint64_t unknown = 0;

    // ALWAYS CHECK THE PHASE that espresso outputs or you will get confused
    // Begin Autogenerated
    unknown |= stateon & (~on1) & (~on0) & (unk1 | unk0);
    unknown |= (~on2) & unk1 & (on1 | on0 | unk0);
    unknown |= (~on2) & on1 & unk0 & ~((stateunk | stateon) & on0);
    next_on |= (stateunk | stateon | ~unk0) & (~on2) & on1 & on0 & (~unk1);
    next_on |= stateon & (~on1) & (~on0) & (~unk1) & (~unk0);
    // End Autogenerated

    result.state[i] = next_on;
    result.unknown[i] = unknown;

    // Remove unknown cells that we have decided were glancing
    // Careful: stable.state0/1/2 may be out of date when this
    // function is called, so think very hard before adjusting this
    uint64_t glanceSafe =
      unknown & ~(stateon | stateunk | stable.state2[i] | stable.state1[i] | stable.state0[i] | on2 | on1);
    result.unknown[i] &= ~(glanceSafe & stable.glanced[i]);
  }

  LifeState uneqStable = (state ^ stable.state) | (unknownStable ^ stable.unknownStable) | (unknown & ~unknownStable);
  LifeState toRestore = ~uneqStable.ZOI() & result.unknown;
  // Anything in the neighbourhood
  result.state = (result.state & ~toRestore) | (stable.state & toRestore);
  result.unknown = (result.unknown & ~toRestore) | (stable.unknownStable & toRestore);
  result.unknownStable = stable.unknownStable & toRestore;

  return result;
}

LifeUnknownState LifeUnknownState::UncertainStepMaintaining(const LifeStableState &stable) const {
  LifeUnknownState result;

  LifeState state3(false), state2(false), state1(false), state0(false);
  LifeState unknown3(false), unknown2(false), unknown1(false), unknown0(false);

  CountNeighbourhood(state, state3, state2, state1, state0);
  CountNeighbourhood(unknown, unknown3, unknown2, unknown1, unknown0);

  #pragma clang loop unroll(full)
  for (int i = 0; i < N; i++) {
    uint64_t on3 = state3[i];
    uint64_t on2 = state2[i];
    uint64_t on1 = state1[i];
    uint64_t on0 = state0[i];

    uint64_t unk3 = unknown3[i];
    uint64_t unk2 = unknown2[i];
    uint64_t unk1 = unknown1[i];
    uint64_t unk0 = unknown0[i];

    on2 |= on3;
    on1 |= on3;
    on0 |= on3;

    unk1 |= unk2 | unk3;
    unk0 |= unk2 | unk3;

    uint64_t stateon = state[i];
    uint64_t stateunk = unknown[i];

    uint64_t next_on = 0;
    uint64_t unknown = 0;

    // ALWAYS CHECK THE PHASE that espresso outputs or you will get confused
    // Begin Autogenerated
    unknown |= stateon & (~on1) & (~on0) & (unk1 | unk0);
    unknown |= (~on2) & unk1 & (on1 | on0 | unk0);
    unknown |= (~on2) & on1 & unk0 & ~((stateunk | stateon) & on0);
    next_on |= (stateunk | stateon | ~unk0) & (~on2) & on1 & on0 & (~unk1);
    next_on |= stateon & (~on1) & (~on0) & (~unk1) & (~unk0);
    // End Autogenerated

    result.state[i] = next_on;
    result.unknown[i] = unknown;

    uint64_t common_part = unknown &
//      & ~any_unstable_unknown
      ~(stateon | stateunk | stable.state2[i] | stable.state1[i] | on2);

    uint64_t glanceable =
      common_part
      & (~stable.state0[i])
      & (~on1) & on0
      & (unk1 | unk0);
    result.glanceableUnknown[i] = glanceable;

    // Remove unknown cells that we have decided were glancing
    uint64_t glanceSafe = common_part & ~stable.state0[i] & ~on1;
    result.unknown[i] &= ~(glanceSafe & stable.glanced[i]);
  }

  #pragma clang loop unroll(full)
  for (int i = 0; i < N; i++) {
    uint64_t unequal_stable =
        (state[i] ^ stable.state[i]) | (unknownStable[i] ^ stable.unknownStable[i]) |
         state3[i]                     | (state2[i] ^ stable.state2[i]) |
        (state1[i] ^ stable.state1[i]) | (state0[i] ^ stable.state0[i]) |
        (unknown3[i] ^ stable.unknown3[i]) | (unknown2[i] ^ stable.unknown2[i]) |
        (unknown1[i] ^ stable.unknown1[i]) | (unknown0[i] ^ stable.unknown0[i]);

    uint64_t toRestore = ~unequal_stable & result.unknown[i];

    // Prevent unknown region from expanding
    result.state[i] = (result.state[i] & ~toRestore) | (stable.state[i] & toRestore);
    result.unknown[i] = (result.unknown[i] & ~toRestore) | (stable.unknownStable[i] & toRestore);
    result.unknownStable[i] = stable.unknownStable[i] & toRestore;
  }

  return result;
}

void LifeUnknownState::UncertainStepColumn(int column, uint64_t &next, uint64_t &nextUnknown) const {
  std::array<uint64_t, 4> nearbyState;
  std::array<uint64_t, 4> nearbyUnknown;

  for (int i = 0; i < 4; i++) {
    int c = (column + i - 1 + N) % N;
    nearbyState[i] = state[c];
    nearbyUnknown[i] = unknown[c];
  }

  std::array<uint64_t, 4> oncol0;
  std::array<uint64_t, 4> oncol1;
  std::array<uint64_t, 4> unkcol0;
  std::array<uint64_t, 4> unkcol1;

  for (int i = 0; i < 4; i++) {
    uint64_t a = nearbyState[i];
    uint64_t l = RotateLeft(a);
    uint64_t r = RotateRight(a);

    oncol0[i] = l ^ r ^ a;
    oncol1[i] = ((l ^ r) & a) | (l & r);
  }

  for (int i = 0; i < 4; i++) {
    uint64_t a = nearbyUnknown[i];
    uint64_t l = RotateLeft(a);
    uint64_t r = RotateRight(a);

    unkcol0[i] = l ^ r ^ a;
    unkcol1[i] = ((l ^ r) & a) | (l & r);
  }

  {
    int idxU = 0;
    int i = 1;
    int idxB = 2;

    uint64_t on3, on2, on1, on0;
    uint64_t unk3, unk2, unk1, unk0;

    {
      uint64_t u_on1 = oncol1[idxU];
      uint64_t u_on0 = oncol0[idxU];
      uint64_t c_on1 = oncol1[i];
      uint64_t c_on0 = oncol0[i];
      uint64_t l_on1 = oncol1[idxB];
      uint64_t l_on0 = oncol0[idxB];

      uint64_t uc0, uc1, uc2, uc_carry0;
      HalfAdd(uc0, uc_carry0, u_on0, c_on0);
      FullAdd(uc1, uc2, u_on1, c_on1, uc_carry0);

      uint64_t on_carry1, on_carry0;
      HalfAdd(on0, on_carry0, uc0, l_on0);
      FullAdd(on1, on_carry1, uc1, l_on1, on_carry0);
      HalfAdd(on2, on3, uc2, on_carry1);
      on2 |= on3;
      on1 |= on3;
      on0 |= on3;

      uint64_t u_unk1 = unkcol1[idxU];
      uint64_t u_unk0 = unkcol0[idxU];
      uint64_t c_unk1 = unkcol1[i];
      uint64_t c_unk0 = unkcol0[i];
      uint64_t l_unk1 = unkcol1[idxB];
      uint64_t l_unk0 = unkcol0[idxB];

      uint64_t ucunk0, ucunk1, ucunk2, ucunk_carry0;
      HalfAdd(ucunk0, ucunk_carry0, u_unk0, c_unk0);
      FullAdd(ucunk1, ucunk2, u_unk1, c_unk1, ucunk_carry0);

      uint64_t unk_carry1, unk_carry0;
      HalfAdd(unk0, unk_carry0, ucunk0, l_unk0);
      FullAdd(unk1, unk_carry1, ucunk1, l_unk1, unk_carry0);
      HalfAdd(unk2, unk3, ucunk2, unk_carry1);
      unk1 |= unk2 | unk3;
      unk0 |= unk2 | unk3;
    }

    uint64_t stateon = nearbyState[i];
    uint64_t stateunk = nearbyUnknown[i];

    uint64_t next_on = 0;
    uint64_t unknown = 0;

    // ALWAYS CHECK THE PHASE that espresso outputs or you will get confused
// Begin Autogenerated
unknown |= (~on2) & unk1 & (on1 | on0 | unk0);
unknown |= stateon & (~on1) & (~on0) & (unk1 | unk0) ;
unknown |= (~stateunk) & (~stateon) & (~on2) & on1 & unk0 ;
unknown |= (~on2) & on1 & (~on0) & unk0 ;
next_on |= (stateunk | stateon | ~unk0) & (~on2) & on1 & on0 & (~unk1) ;
next_on |= stateon & (~on1) & (~on0) & (~unk1) & (~unk0) ;
// End Autogenerated

    next = next_on;
    nextUnknown = unknown;
  }
}

std::pair<bool, bool> LifeUnknownState::NextForCell(std::pair<int, int> cell) const {
  uint64_t nextColumn;
  uint64_t nextUnknownColumn;

  UncertainStepColumn(cell.first, nextColumn, nextUnknownColumn);

  int y = cell.second;
  bool cellNext    = (nextColumn & (1ULL << y)) >> y;
  bool cellUnknown = (nextUnknownColumn & (1ULL << y)) >> y;
  return {cellNext, cellUnknown};
}

bool LifeUnknownState::KnownNext(std::pair<int, int> cell) const {
  return !NextForCell(cell).second;
}


LifeState LifeUnknownState::ActiveComparedTo(const LifeStableState &stable) const {
  return ~unknown & ~stable.unknownStable & stable.stateZOI & (stable.state ^ state);
}

bool LifeUnknownState::CompatibleWith(const LifeStableState &stable) const {
  return ActiveComparedTo(stable).IsEmpty();
}

bool LifeUnknownState::StillGlancingFor(std::pair<int, int> cell, const LifeStableState &stable) const {
  return !stable.state2.Get(cell) && !stable.state1.Get(cell) &&
    (stable.unknown3.Get(cell) || stable.unknown2.Get(cell) || stable.unknown1.Get(cell) || stable.unknown0.Get(cell));
}
