#pragma once

#include "LifeAPI.h"
#include "Bits.hpp"
#include "LifeStableState.hpp"
#include "LifeHistoryState.hpp"

// Maybe this should just be a bitset + constants
enum class Transition : unsigned char {
  OFF_TO_OFF       = 1 << 0,
  OFF_TO_ON        = 1 << 1,
  ON_TO_OFF        = 1 << 2,
  ON_TO_ON         = 1 << 3,
  STABLE_TO_STABLE = 1 << 4,
  IMPOSSIBLE       = 0,
};

constexpr inline Transition operator~ (Transition a) { return static_cast<Transition>( ~static_cast<std::underlying_type<Transition>::type>(a) ); }
constexpr inline Transition operator| (Transition a, Transition b) { return static_cast<Transition>( static_cast<std::underlying_type<Transition>::type>(a) | static_cast<std::underlying_type<Transition>::type>(b) ); }
constexpr inline Transition operator& (Transition a, Transition b) { return static_cast<Transition>( static_cast<std::underlying_type<Transition>::type>(a) & static_cast<std::underlying_type<Transition>::type>(b) ); }
constexpr inline Transition operator^ (Transition a, Transition b) { return static_cast<Transition>( static_cast<std::underlying_type<Transition>::type>(a) ^ static_cast<std::underlying_type<Transition>::type>(b) ); }
constexpr inline Transition& operator|= (Transition& a, Transition b) { a = a | b; return a; }
constexpr inline Transition& operator&= (Transition& a, Transition b) { a = a & b; return a; }
constexpr inline Transition& operator^= (Transition& a, Transition b) { a = a ^ b; return a; }

Transition TransitionLowest(Transition t) {
  unsigned char bits = static_cast<unsigned char>(t);
  return static_cast<Transition>(bits & (~bits + 1));
}

bool TransitionIsSingleton(Transition t) {
  unsigned char bits = static_cast<unsigned char>(t);
  return bits && !(bits & (bits-1));
}

class LifeUnknownState {
public:
  LifeState state;
  LifeState unknown;
  LifeState unknownStable; // Equal to the stable state

  LifeUnknownState UncertainStepMaintaining(const LifeStableState &stable) const;
  // bool CanCleanlyAdvance(const LifeStableState &stable) const;
  LifeState ActiveComparedTo(const LifeStableState &stable) const;
  LifeState ChangesComparedTo(const LifeUnknownState &prev) const;
  void TransferStable(const LifeStableState &stable);

  void SetKnown(std::pair<int, int> cell, bool value, bool stable) {
    if (stable) {
      unknownStable.Set(cell);
    } else {
      state.Set(cell, value);
      unknown.Set(cell, false);
      unknownStable.Set(cell, false);
    }
  }
  void SetTransitionResult(std::pair<int, int> cell, Transition transition) {
    switch (transition) {
    case Transition::OFF_TO_OFF:
    case Transition::ON_TO_OFF:
      SetKnown(cell, false, false);
      break;
    case Transition::OFF_TO_ON:
    case Transition::ON_TO_ON:
      SetKnown(cell, true, false);
      break;
    case Transition::STABLE_TO_STABLE:
      SetKnown(cell, false, true);
      break;
    }
  }
};

LifeUnknownState LifeUnknownState::UncertainStepMaintaining(const LifeStableState &stable) const {
  LifeUnknownState result;

  LifeState activeUnknownZOI = (unknown & ~unknownStable).ZOI();
  // LifeState keepStable;

  LifeState state3(false), state2(false), state1(false), state0(false);
  LifeState unknown3(false), unknown2(false), unknown1(false), unknown0(false);

  CountNeighbourhood(state, state3, state2, state1, state0);
  CountNeighbourhood(unknown, unknown3, unknown2, unknown1, unknown0);

  #pragma clang loop unroll(full)
  for (int i = 0; i < N; i++) {
    uint64_t on3 = state3[i];
    uint64_t on2 = state2[i];
    uint64_t on1 = state1[i];
    uint64_t on0 = state0[i];

    uint64_t unk3 = unknown3[i];
    uint64_t unk2 = unknown2[i];
    uint64_t unk1 = unknown1[i];
    uint64_t unk0 = unknown0[i];

    uint64_t stateon = state[i];
    uint64_t stateunk = unknown[i];

    on2 |= on3;
    on1 |= on3;
    on0 |= on3;

    unk1 |= unk2 | unk3;
    unk0 |= unk2 | unk3;

    uint64_t next_on = 0;
    uint64_t next_unknown = 0;

    // ALWAYS CHECK THE PHASE that espresso outputs or you will get confused
    // Begin Autogenerated, see bitslicing/unknown_step.py
    next_unknown |= stateon & (~on1) & (~on0) & (unk1 | unk0);
    next_unknown |= (~on2) & unk1 & (on1 | on0 | unk0);
    next_unknown |= (~on2) & on1 & unk0 & ~((stateunk | stateon) & on0);
    next_on |= (stateunk | stateon | ~unk0) & (~on2) & on1 & on0 & (~unk1);
    next_on |= stateon & (~on1) & (~on0) & (~unk1) & (~unk0);
    // End Autogenerated

    result.state[i] = next_on;
    result.unknown[i] = next_unknown;

    uint64_t l2 = stable.live2[i];
    uint64_t l3 = stable.live3[i];
    uint64_t d0 = stable.dead0[i];
    uint64_t d1 = stable.dead1[i];
    uint64_t d2 = stable.dead2[i];
    uint64_t d4 = stable.dead4[i];
    uint64_t d5 = stable.dead5[i];
    uint64_t d6 = stable.dead6[i];

    uint64_t s2 = stable.state2[i];
    uint64_t s1 = stable.state1[i];
    uint64_t s0 = stable.state0[i];

    uint64_t keep_stable = 0;

    // Begin Autogenerated, see bitslicing/unknown_keep.py
keep_stable |= l2 & l3 & on2;
keep_stable |= l3 & s1 & s0 & on2 & (~on1) & (~on0);
keep_stable |= l3 & d6 & s2 & (~on1);
keep_stable |= l3 & s2 & (~on1) & (~on0);
keep_stable |= s1 & s0 & (~on2) & on1 & on0;
keep_stable |= (~s1) & s0 & (~on2) & (~on1) & on0;
keep_stable |= s1 & (~s0) & (~on2) & on1 & (~on0);
keep_stable |= l2 & d4 & (~s1) & s0 & (~on2) & (~on1);
keep_stable |= l2 & l3 & d1 & d5 & s0 & on0;
keep_stable |= l2 & l3 & d1 & d5 & (~s0) & (~on0);
keep_stable |= l2 & d4 & s1 & (~on2) & on1 & (~on0);
keep_stable |= (~s2) & (~s1) & (~s0) & (~on2) & (~on1) & (~on0);
keep_stable |= l3 & d2 & (~s2) & s1 & (~on2) & on1 & on0;
keep_stable |= d4 & s2 & (~s1) & (~s0) & (~on2) & on1 & on0;
keep_stable |= l3 & d2 & (~s2) & (~s1) & (~on2) & (~on1) & on0;
keep_stable |= l2 & d4 & s1 & (~s0) & (~on2) & (~on1) & on0;
keep_stable |= l2 & l3 & d2 & d4 & d6 & s0 & (~on0);
keep_stable |= l2 & l3 & d1 & (~s2) & (~s0) & on1 & (~on0);
keep_stable |= l2 & l3 & d6 & s1 & s0 & (~on1) & (~on0);
keep_stable |= l2 & l3 & d0 & d1 & (~s2) & (~s1) & on1 & on0;
keep_stable |= l2 & l3 & d0 & (~s2) & (~s1) & (~s0) & on1 & on0;
keep_stable |= l3 & d2 & (~s2) & (~s1) & s0 & (~on2) & on1 & (~on0);
keep_stable |= d0 & d1 & d2 & d4 & (~s1) & (~s0) & on2 & (~on1) & (~on0);
    // End Autogenerated

    keep_stable &= ~activeUnknownZOI[i] & result.unknown[i];
    // keepStable[i] = keep_stable;

    // Restore anything that should be kept stable
    result.state[i] = (result.state[i] & ~keep_stable) | (state[i] & keep_stable);
    result.unknown[i] = (result.unknown[i] & ~keep_stable) | (unknown[i] & keep_stable);
    result.unknownStable[i] = (result.unknownStable[i] & ~keep_stable) | (unknownStable[i] & keep_stable);
  }

  // LifeHistoryState history(state, unknown, keepStable, LifeState());
  // std::cout << history.RLEWHeader() << std::endl;
  // exit(0);

  return result;
}

LifeState LifeUnknownState::ActiveComparedTo(const LifeStableState &stable) const {
  return ~unknown & ~stable.unknown & stable.stateZOI & (stable.state ^ state);
}

void LifeUnknownState::TransferStable(const LifeStableState &stable) {
  LifeState updated = unknownStable & ~stable.unknown;
  state |= stable.state & updated;
  unknown &= ~updated;
  unknownStable &= ~updated;
}

LifeState
LifeUnknownState::ChangesComparedTo(const LifeUnknownState &prev) const {
  return (state ^ prev.state) & ~unknown & ~prev.unknown;
}
