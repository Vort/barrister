#pragma once

#include "LifeAPI.h"
#include "Bits.hpp"
#include "LifeStableState.hpp"

class LifeUnknownState {
public:
  LifeState state;
  LifeState unknown;
  LifeState unknownStable;
  LifeState glanceableUnknown;

  LifeUnknownState UncertainStepMaintaining(const LifeStableState &stable) const;
  LifeState ActiveComparedTo(const LifeStableState &stable) const;
  bool CompatibleWith(const LifeStableState &stable) const;

  std::tuple<uint64_t, uint64_t, uint64_t> UncertainStepColumn(const LifeStableState &stable, int column) const;
  std::tuple<bool, bool, bool> NextForCell(const LifeStableState &stable, std::pair<int, int> cell) const;
  bool KnownNext(const LifeStableState &stable, std::pair<int, int> cell) const;

  bool StillGlancingFor(std::pair<int, int> cell, const LifeStableState &stable) const;
};

LifeUnknownState LifeUnknownState::UncertainStepMaintaining(const LifeStableState &stable) const {
  LifeUnknownState result;

  LifeState state3(false), state2(false), state1(false), state0(false);
  LifeState unknown3(false), unknown2(false), unknown1(false), unknown0(false);

  CountNeighbourhood(state, state3, state2, state1, state0);
  CountNeighbourhood(unknown, unknown3, unknown2, unknown1, unknown0);

  LifeState unequal_stable = (state ^ stable.state) | (unknownStable ^ stable.unknownStable) |
         state3                     | (state2 ^ stable.state2) |
        (state1 ^ stable.state1) | (state0 ^ stable.state0) |
        (unknown3 ^ stable.unknown3) | (unknown2 ^ stable.unknown2) |
        (unknown1 ^ stable.unknown1) | (unknown0 ^ stable.unknown0);

  #pragma clang loop unroll(full)
  for (int i = 0; i < N; i++) {
    uint64_t on3 = state3[i];
    uint64_t on2 = state2[i];
    uint64_t on1 = state1[i];
    uint64_t on0 = state0[i];

    uint64_t unk3 = unknown3[i];
    uint64_t unk2 = unknown2[i];
    uint64_t unk1 = unknown1[i];
    uint64_t unk0 = unknown0[i];

    on2 |= on3;
    on1 |= on3;
    on0 |= on3;

    unk1 |= unk2 | unk3;
    unk0 |= unk2 | unk3;

    uint64_t stateon = state[i];
    uint64_t stateunk = unknown[i];

    uint64_t next_on = 0;
    uint64_t unknown = 0;

    // ALWAYS CHECK THE PHASE that espresso outputs or you will get confused
    // Begin Autogenerated
    unknown |= stateon & (~on1) & (~on0) & (unk1 | unk0);
    unknown |= (~on2) & unk1 & (on1 | on0 | unk0);
    unknown |= (~on2) & on1 & unk0 & ~((stateunk | stateon) & on0);
    next_on |= (stateunk | stateon | ~unk0) & (~on2) & on1 & on0 & (~unk1);
    next_on |= stateon & (~on1) & (~on0) & (~unk1) & (~unk0);
    // End Autogenerated

    result.state[i] = next_on;
    result.unknown[i] = unknown;

    uint64_t common_part = unknown &
//      & ~any_unstable_unknown
      ~(stateon | stateunk | stable.state2[i] | stable.state1[i] | on2);

    uint64_t glanceable =
      common_part
      & (~stable.state0[i])
      & (~on1) & on0
      & (unk1 | unk0);
    result.glanceableUnknown[i] = glanceable;

    // Remove unknown cells that we have decided were glancing
    uint64_t glanceSafe = common_part & ~stable.state0[i] & ~on1;
    result.unknown[i] &= ~(glanceSafe & stable.glanced[i]);

    uint64_t toRestore = ~unequal_stable[i] & result.unknown[i];

    result.state[i] = (result.state[i] & ~toRestore) | (stable.state[i] & toRestore);
    result.unknown[i] = (result.unknown[i] & ~toRestore) | (stable.unknownStable[i] & toRestore);
    result.unknownStable[i] = stable.unknownStable[i] & toRestore;
  }

  return result;
}

std::tuple<uint64_t, uint64_t, uint64_t> LifeUnknownState::UncertainStepColumn(const LifeStableState &stable, int column) const {
  auto [on3, on2, on1, on0] = CountNeighbourhoodColumn(state, column);
  auto [unk3, unk2, unk1, unk0] = CountNeighbourhoodColumn(unknown, column);

  uint64_t stateon = state[column];
  uint64_t stateunk = unknown[column];
  uint64_t stateunkstable = unknownStable[column];

  uint64_t unequal_stable =
    (stateon ^ stable.state[column]) | (stateunkstable ^ stable.unknownStable[column]) |
    on3                              | (on2 ^ stable.state2[column]) |
    (on1 ^ stable.state1[column])    | (on0 ^ stable.state0[column]) |
    (unk3 ^ stable.unknown3[column]) | (unk2 ^ stable.unknown2[column]) |
    (unk1 ^ stable.unknown1[column]) | (unk0 ^ stable.unknown0[column]);

  on2 |= on3;
  on1 |= on3;
  on0 |= on3;
  unk1 |= unk2 | unk3;
  unk0 |= unk2 | unk3;

  uint64_t next_on = 0;
  uint64_t unknown = 0;

  // ALWAYS CHECK THE PHASE that espresso outputs or you will get confused
  // Begin Autogenerated
  unknown |= (~on2) & unk1 & (on1 | on0 | unk0);
  unknown |= stateon & (~on1) & (~on0) & (unk1 | unk0) ;
  unknown |= (~stateunk) & (~stateon) & (~on2) & on1 & unk0 ;
  unknown |= (~on2) & on1 & (~on0) & unk0 ;
  next_on |= (stateunk | stateon | ~unk0) & (~on2) & on1 & on0 & (~unk1) ;
  next_on |= stateon & (~on1) & (~on0) & (~unk1) & (~unk0) ;
  // End Autogenerated

  uint64_t unknownStable = ~unequal_stable & unknown;

  return {next_on, unknown, unknownStable};
}

std::tuple<bool, bool, bool> LifeUnknownState::NextForCell(const LifeStableState &stable, std::pair<int, int> cell) const {
  auto [nextColumn, nextUnknownColumn, nextUnknownStableColumn] = UncertainStepColumn(stable, cell.first);

  int y = cell.second;
  bool cellNext    = (nextColumn & (1ULL << y)) >> y;
  bool cellUnknown = (nextUnknownColumn & (1ULL << y)) >> y;
  bool cellUnknownStable = (nextUnknownStableColumn & (1ULL << y)) >> y;
  return {cellNext, cellUnknown, cellUnknownStable};
}

bool LifeUnknownState::KnownNext(const LifeStableState &stable, std::pair<int, int> cell) const {
  auto [cellNext, cellUnknown, cellUnknownStable] = NextForCell(stable, cell);
  return !cellUnknown || cellUnknownStable;
}

LifeState LifeUnknownState::ActiveComparedTo(const LifeStableState &stable) const {
  return ~unknown & ~stable.unknownStable & stable.stateZOI & (stable.state ^ state);
}

bool LifeUnknownState::CompatibleWith(const LifeStableState &stable) const {
  return ActiveComparedTo(stable).IsEmpty();
}

bool LifeUnknownState::StillGlancingFor(std::pair<int, int> cell, const LifeStableState &stable) const {
  return !stable.state2.Get(cell) && !stable.state1.Get(cell) &&
    (stable.unknown3.Get(cell) || stable.unknown2.Get(cell) || stable.unknown1.Get(cell) || stable.unknown0.Get(cell));
}
